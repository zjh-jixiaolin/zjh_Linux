# Linux 用户和用户组管理


[TOC]

文档：[link](http://c.biancheng.net/view/705.html)

## 0. 用户和用户组

用户和用户组管理，顾名思义就是`添加`用户和用户组、更改密码和设定权限等操作。

### 用户

`Linux`是多用户多任务操作系统，换句话说，Linux系统支持 **多个用户在同一时间内登录，不同用户执行不同的任务**，互不影响。

例：Linux服务器有4个用户，分别为`root、www、ftp、mysql`，在同一时间内，`root`用户在查看系统日志，管理维护系统；`www`用户在修改网页程序；`ftp`用户在上传文件到服务器；`mysql`用户在执行自己的`SQL`查询。

> **不同用户具有不同的权限，每个用户在权限允许的范围内完成不间的任务，Linux 正是通过这种权限的划分与管理，实现了多用户多任务的运行机制。**
>
> **每个用户都有唯一的用户名和密码。**

### 用户组

用户组是具有 **相同特征**用户的逻辑集合。

简单理解，有时我们需要让多个用户具有相同的权限，比如查看、修改某个文件的权限，一种方法是对多个用户进行授权，但如果当用户有上百或者更多时，显然这种方法不高效。

最好的方式：建立一个组，这个组有查看、修改此文件的权限，如果将需要访问此文件的用户加入这个组中，那么，所有用户就具有和组一样的权限，这就是用户组。

>为什么要用户和用户组的管理？
>
>​	企业服务器大多以`Linux`为主，网站的建设以及软件服务都是在服务器上运行的，不是所有的数据都对每位管理员公开，避免的重要数据被删除和系统被破坏。如果运维团队中某位管理员对`Linux`不熟悉，这将是灾难性的，因此，越是对安全性要求高的服务器，越需要建立合理的用户权限等级制度和服务器操作规范。

### 用户和用户组的关系

用户和用户组的对应关系有以下`4`种：

1. 一对一：一个用户存在一个组中，是组中的唯一成员；
2. 一对多：一个用户存在多个用户组中，此用户具有多个组的共同权限；
3. 多对一：多个用户存在一个组中，所有用户具有和组相同的权限；
4. 多对多：多个用户存在多个组中，为以上`3`种关系的扩展；

![image-20230504111134838](https://raw.githubusercontent.com/zjh-jixiaolin/map_strong/main/202305041111096.png)

## 1. UID 和 GID

登录 `Linux`系统时，虽然输入的是自己的用户名和密码，但 `Linux`不认识用户名称，它只认识用户名对应的 `ID`号（一串数字）。`Linux`系统将所有用户名称和 `ID`对应的关系都存储在 `/etc/passwd`文件中。

>用户名无实际作用，方便用户记忆而已。

`Linux` 系统中，每个用户的`ID`细分为`2`种：

- `UID`：用户ID，简称 `User ID`。
- `GID`：组ID，简称 `Group ID`。

![image-20230504195040444](https://raw.githubusercontent.com/zjh-jixiaolin/map_strong/main/202305042012842.png)



### 文件拥有者 和 文件所属组

---

在 `Linux` 中，每个文件都拥有自己的 `拥有者ID` 和 `群组ID`，当显示文件属性时（ls -l），系统会根据 `/etc/passwd` 和 `/etc/group`文件中的内容，分别找到`UID`和`GID`对应的用户名和群组名，并显示。

- 在 `/etc/passwd`文件中，利用 `UID` 可以找到对应的用户名。
- 在 `/etc/group`文件中，利用 `GID` 可以找到对应的群组名。

>`UID`和`GID`与**文件拥有者**和**文件所属组**两种属性相对应。



<br />



### /etc/passwd 系统用户配置

---

`Linux` 系统中的 `/etc/passwd`文件，是**系统用户**配置文件，存储了系统中所有用户的基本信息，所有用户都可以对此文件有 **读** 的权限。文件内容如下：

```bash
[zjh@localhost ~]$ cat /etc/passwd
-------------------------------------------
# 每行记录对应一个用户
> root:x:0:0:root:/root:/bin/bash
> bin:x:1:1:bin:/bin:/sbin/nologin
> zjh:x:1000:1000:zjh:/home/zjh:/bin/bash
> ntp:x:38:38::/etc/ntp:/sbin/nologin
> zjd:x:1001:1001::/home/zjd:/bin/bash
> # .... 省略输出 ....

-------------------------------------------

```

>`Linux` 系统会默认拥有很多用户，这些用户大多数是系统或服务运行时所需的用户，称为 **系统用户**或 **伪用户**。系统用户无法原来登录系统，也不可删除。删除会导致用户运行的服务或程序不能正常执行，会导致系统问题。

每行用户信息都以 `:` 作为分隔符，划分为`7`个字段，每个字段所表示的含义如下：

```bash
用户名 | 密码 | UID（用户ID）| GID（组ID）| 描述性信息 | 主目录 | 默认Shell
```

#### 用户名

用户名，就是一串代表用户身份的字符串。

用户名仅是为了方便用户记忆，`Linux` 系统通过 `UID` 来识别用户身份，分配用户权限的。`/etc/passwd`文件中就定义了 **用户名** 和 **UID** 之间对应的关系。

#### 密码

`x` 表示此用户拥有密码，但不是真正的密码，真正的密码保存在 `/etc/shadow`文件中。

这里的 `x` 表示用户的密码已经被加密并存储在另一个文件中（/etc/shadow）。

#### UID

用户`ID`，每个用户都有唯一的一个`UID`，`Linux`系统中通过 `UID` 来识别不同的用户。

实际上，`UID`是一个 `0 - 65535` 之间的数，不同范围内的数字表示不同的用户身份，如下表所示：

| UID 范围    | 用户身份                                                     |
| ----------- | ------------------------------------------------------------ |
| 0           | 超级用户，`UID`为0表示这个账号为管理员账号。在 `Linux` 中，将其他用户的`UID`修改为`0`即可将普通用户升级为管理员，但是不建议设立多个管理员账户。 |
| 1 ~ 499     | 系统用户（伪用户），即此范围的 `UID` 保留给系统使用。其中，`1 ~ 99`用于系统自行创建的账号；`100 ~ 499`分配给系统账号需求的用户。 |
| 500 ~ 65535 | 普通用户，创建普通用户会在此范围分配 `UID`。                 |

>需注意，不同`Linux` 发行版可能会有所不同。有些系统将`UID`从`0`到`999`分配给系统用户和服务账户，例如红帽`CentOS7`。

#### GID

组`ID`，表示用户初始组的组`ID`号。这里分别介绍一下 **初始组** 和 **附加组** 的概念。

- **初始组**：指用户登陆时就拥有这个用户组的相关权限。每个用户的初始组只能有一个，通常是将和此用户的用户名相同的组名作为该用户的初始组。
  - 如：添加用户`test`，在建立用户`test`的同时，就会建立`test组`作为`test`用户的初始组。
- **附加组**：指用户可以加入 **多个**其他的用户组，并拥有这些组的权限。每个用户只能有一个初始组，除初始组外，用户加入其他的用户组，这些用户组就是这个用户的 **附加组**。附加组可以拥有多个，而用户可以有这些附加组的权限。
  - 如：上方`test`用户属于初始组`test`外，又将它加入`users`组，那么`test`用户同时属于`test`组和`users`组，其中`test`是初始组，`users`是附加组。

>注意：在 `/etc/passwd`  文件的第四个字段中看到的`ID`是这个用户的初始组。

#### 描述性信息

无特殊用途，用来解释这个用户的意义而已。

#### 主目录

用户登录后有操作权限的访问命令，称为用户的主目录。

#### 默认的Shell

`Shell`就是`Linux`的命令解释器，是用户和 `Linux` 内核之间沟通的桥梁。

熟知，用户登录 `Linux` 系统后，通过 `Linux` 命令完成操作任务，但系统只认识类似`0101`的机器语言，这里就需要命令解释器。`Shell`命令解释器的功能就是将用户输入的命令转换成系统可以识别的机器语言。



<br />



### /etc/shadow 用户信息

---

`/etc/shadow`文件，用于存储 `Linux` 系统中用户的密码信息，又称**影子文件**。

`/etc/shadow`文件只有`root`用户拥有读权限，其他用户没有任何权限，这就保证了用户密码的安全性。文件内容如下：

```bash
[root@localhost ~]# cat /etc/shadow
-------------------------------------------
# 每行记录对应一个用户密码信息
root:$6$inEMyMhq$6mqm6u4r.moKZMX8ti5lA.xzXxJ7gX7w730OMsnKQZwDAfmplGPcWo4uck0l91lQ0JB8GhxoAcCFFBIrVuaBv.:19482:0:99999:7:::
sshd:!!:19471::::::
postfix:!!:19471::::::
bin:*:17834:0:99999:7:::
zjh:$6$hyLvUl6X$Ge/.Z4GuEKE6cXwaa.HR1cXHUnD3byCqkVpfTREH59NXEfwiEwH.dz6kXe9NBRxh57psCvQgbW2KbN/s6tO/p1:19482:0:99999:7:::
> # .... 省略输出 ....
-------------------------------------------

```

文件中每行代表一个用户密码信息，同样使用 `:` 作为分隔符，不同之处在于，每行用户信息被划分为`9`个字段，含义如下：

```
用户名 | 加密密码 | 最后一次修改时间 | 最小修改时间间隔 | 密码有效期 | 密码变更前的警告天数 | 密码过去后宽限的天数 | 账号失效时间 | 保留
```

#### 用户名

用户名，就是一串代表用户身份的字符串。

#### 加密密码

这里保存的是真正 **加密**的密码，目前 `Linux` 密码采用 `SHA512` 散开加密算法。原来采用的`MD5` 和`DES` 加密算法，`SHA512`散列加密算法的加密等级更高，更安全。

>所有 **伪用户（系统用户）**的密码都是 `!!` 或 `*`，代表没有密码不能登录。
>
>新创建的用户如果不设定密码，则密码项也是`!!`，代表用户没有密码，不能登录。

#### 最后一次修改时间

此字段表示最后一次修改密码的时间，但为什么`root`用户显示为`19482`?

因为 `Linux` 计算日期的时间是以 `1997.1.1` 作为 `1`不断累加得到的时间，到 `1971.1.1`，则为 `366`天。这里显示`19482`天，即此 `root`账户在 `1970.1.1`之后的第`19482`天修改的`root`用户的密码。

```bash
# 转换成习惯的系统日期
[root@localhost ~]# date -d "1970-01-01 19482 days" +"%Y-%m-%d %H:%M:%S"
> 2023-05-05 00:00:00

```

#### 最小修改时间间隔

多长时间之内不能修改密码。如果是 `0`，则密码可以随时修改；如果是 `10`，则代表密码修改后 `10` 天之内不能再次修改密码。

#### 密码有效期

该字段的默认值为 `99999`，也就是 `273` 年，可认为是永久生效。

如果改为 `90`，则表示密码被修改 `90` 天之后必须再次修改，否则该用户即将过期。

#### 密码需要变更前的警告天数

当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 `再过 n 天你的密码就要过期了，请尽快重新设置你的密码！`。

默认值为 `7` ，意为距离密码有效期的第`7`天开始，每次登录系统都会将该账户发出修改密码的警告。

#### 密码过期后的宽限天数

在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；

#### 账号失效时间

使用自 `1970.1.1` 以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！

该字段通常被使用在具有**收费服务**的系统中。

#### 保留

无任何意义，等待新功能加入

### 忘记密码解决方法

---

对于 **普通用户**密码遗失，通过 `root`账户解决。使用`passwd`重设指定账户的密码。

```bash
[root@localhost ~]# passwd zjh
-------------------------------------------
> Changing password for user zjh.
> New password:
> BAD PASSWORD: The password contains the user name in some form
> Retype new password:
> passwd: all authentication tokens updated successfully.
-------------------------------------------

```

如果 **root管理员** 密码遗失，则需要重新启动进入单用户模式，具体见 [教程](https://github.com/zjh-jixiaolin/Red_Hat_Certificate/blob/master/RHCSA_Notes/%E8%99%9A%E6%8B%9F%E6%9C%BA2%E2%80%94%E7%A0%B4%E8%A7%A3%E5%AF%86%E7%A0%81.md)。



<br />



### /etc/group 系统用户组配置

---

`Linux` 系统中，`/etc/group` 文件是 **用户组**的配置文件，即用户组的所有信息都存放在此文件中。

此文件是记录组`组ID（GID）`和组名相对应的文件，上方 `/etc/passwd`文件信息的第`4`个字段记录的是用户的初始组`ID`。文件内容如下：

```bash
[root@localhost ~]# cat /etc/group
-------------------------------------------
# 每行记录对应一个用户组
> zjh:x:1000:zjh
> wheel:x:10:zjh
> ntp:x:38:
> zjd:x:1001:
> a:x:1002:
> # .... 省略输出 ....

-------------------------------------------
```

各用户组中，以 `:`作为分隔符，划分为 `4` 个字段，每个字段所表示的含义如下：

```bash
组名 | 组密码 | 组ID（GID）| 组中的用户
```

#### 组名

即用户组的名称，由字母或数字构成。同`/etc/passwd`中用户名一致，组名也不能重复。

#### 组密码

与 `/etc/passwd`文件一致，这里 `x` 为密码标识，真正加密后的组密码默认保存在 `/etc/gshadow`文件中。

>用户设置密码是为了验证用户身份，用户组设置密码是用来做什么呢？
>
>用户组密码主要是用来指定组管理员的，由于系统中的账号可能会非常多，root 用户可能没有时间进行用户的组调整，这时可以给用户组指定组管理员，如果有用户需要加入或退出某用户组，可以由该组的组管理员替代 root 进行管理。 
>
>**实际中，很少设置组密码。如果需要赋予某用户调整某个用户组的权限，则使用 sudo 代替。**

#### 组ID（GID）

群组的`ID`号，`Linux`系统就是通过 `GID` 来区分用户组的，组名只是未来便于管理员记忆。

此`GID` 与 `/etc/passwd` 文件第 `4` 字段的 `GID` 相对应。

**`/etc/passwd`文件使用`GID`对应群组名，即通过此文件对应得到的。**

#### 组中的用户

每个群组包含的所有用户。如果该用户组是这个用户的初始组，则该用户不会写入这个字段，简单理解，该字段显示的是 **用户组的附加用户**。

**每个用户都可以加入多个附加组，但是只能属于一个初始组。**



<br />



### /etc/gshadow 用户组信息

---

在`/etc/gshadow`文件，组用户信息存储在 `/etc/group `文件中，而将组用户的密码信息存储在 `/etc/gshadow` 文件中。文件内容如下：

```bash
[root@localhost ~]# cat /etc/gshadow
-------------------------------------------
# 每行记录对应组用户的密码信息
> root:::
> bin:::
> wheel:::zjh
> zjh:!!::zjh
> zjd:!::
> # .... 省略输出 ....

-------------------------------------------
```

每行组用户的密码信息都以 `:`作为分隔符，分为 `4` 个字段，每个字段的含义如下：

```
组名 | 加密密码 | 组管理员 | 组附加用户列表
```

#### 组名

同`/etc/group` 文件中的组名相对应。

#### 组密码

对于大多数用户，通常不设置组密码，该字段为空。但有时为 `!`，指该群组没有组密码，也不设有群组管理员。

#### 组管理员

从系统管理员的角度来说，该文件最大的功能就是创建群组管理员。

目前有`sudo`之类的工具，因此很少使用。

#### 组中的附加用户

显示用户组中有哪些附加用户，和`/etc/group`文件中附加组显示内容相同。



<br />



### /etc/login.defs 用户的默认设置文件

---

`/etc/login.defs` 文件用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户`UID`和`GID`范围，用户的过期时间、密码的最大长度等。

该文件的用户默认配置对 `root` 用户无效，且文件中的配置与 `/etc/passwd` 和 `/etc/shadow`文件中的用户信息有冲突时，系统会以 `/etc/passwd` 和 `/etc/shadow` 为准。

| 设置项                   | 含义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| MAIL_DIR /var/spool/mail | 创建用户时，系统会在目录 /var/spool/mail 中创建一个用户邮箱，比如 lamp 用户的邮箱是 /var/spool/mail/lamp。 |
| PASS_MAX_DAYS 99999      | 密码有效期，99999 是自 1970 年 1 月 1 日起密码有效的天数，相当于 273 年，可理解为密码始终有效。 |
| PASS_MIN_DAYS 0          | 表示自上次修改密码以来，最少隔多少天后用户才能再次修改密码，默认值是 0。 |
| PASS_MIN_LEN 5           | 指定密码的最小长度，默认不小于 5 位，但是现在用户登录时验证已经被 PAM 模块取代，所以这个选项并不生效。 |
| PASS_WARN_AGE 7          | 指定在密码到期前多少天，系统就开始通过用户密码即将到期，默认为 7 天。 |
| UID_MIN 500              | 指定最小 UID 为 500，也就是说，添加用户时，默认 UID 从 500 开始。注意，如果手工指定了一个用户的 UID 是 550，那么下一个创建的用户的 UID 就会从 551 开始，哪怕 500~549 之间的 UID 没有使用。 |
| UID_MAX 60000            | 指定用户最大的 UID 为 60000。                                |
| GID_MIN 500              | 指定最小 GID 为 500，也就是在添加组时，组的 GID 从 500 开始。 |
| GID_MAX 60000            | 用户 GID 最大为 60000。                                      |
| CREATE_HOME yes          | 指定在创建用户时，是否同时创建用户主目录，yes 表示创建，no 则不创建，默认是 yes。 |
| UMASK 077                | 用户主目录的权限默认设置为 077。                             |
| USERGROUPS_ENAB yes      | 指定删除用户的时候是否同时删除用户组，准备地说，这里指的是删除用户的初始组，此项的默认值为 yes。 |
| ENCRYPT_METHOD SHA512    | 指定用户密码采用的加密规则，默认采用 SHA512，这是新的密码加密模式，原先的 Linux 只能用 DES 或 MD5 加密。 |





## 2. 扩展汇总

```bash
# 查看当前用户所属的全部群组
[root@localhost ~]# groups
> root


```



### 







